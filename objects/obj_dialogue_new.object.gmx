<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_dialogue</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-900</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create sliding text for dialogue box 

//Dialogue box 800x360
width = 600;
height = 300;
padding = 16;

//Starting line
start = ds_list_create();
ds_list_add(start, 0);

answersGrid = ds_grid_create(1, 3);

linesDisplayed = 10;

//Last space and current position
count = 0;
lastSpace = 0;
line = 0;
num = 0;
iterator = 0;
message = "";
answer = "";

//Variables set from obj_dialogue_control
info = "";
set_data = false;
pointer = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>bar = instance_create(x + sprite_width - 30,
    y + sprite_height / 2,
    obj_bar_vert);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(set_data)
{
    set_data = false;
    //Reset variables
    ds_list_clear(start);
    ds_list_add(start, 0);
    count = 0;
    message = "";
    lineColor = 0;
    str = "";
    iterator = 0;
    line = 0;
    
    //If line begins with @ it seems that it's NPC's replica
    //If with ~ it's one of the answers variants
    num = array_length_2d(info, pointer);

    var answer_num = 1;
    var answers_pointers = 0;
    
    for(var i = 0; i &lt; num; i++){
        sub_str = string_copy(info[pointer, i], 0, 5);
        num2 = string_digits(sub_str);
        if(string_pos("#", info[pointer, i]) != 0){
            info[pointer, i] = string_replace_all(info[pointer, i], "#", "");
            info[pointer, i] = string_replace_all(info[pointer, i], num2, "");
            message = info[pointer, i];
        }
        if(string_pos("@", info[pointer, i]) != 0){        
            info[pointer, i] = string_replace_all(info[pointer, i], "@", "#");
            info[pointer, i] = string_replace_all(info[pointer, i], num2, string(answer_num++) + ": ");
            answer_pointers[iterator] = real(num2);
            answer[iterator++] = info[pointer, i];
        }
    }
    //Grid for answers
    //It saves x and y positions of answer variant
    //And answer pointer to another NPC-replica
    ds_grid_destroy(answersGrid);
    answersGrid = ds_grid_create(iterator, 3);
    for(i = 0; i &lt; iterator; i++){
        ds_grid_set(answersGrid, i, 0, 0);
        ds_grid_set(answersGrid, i, 1, 0);
        ds_grid_set(answersGrid, i, 2, answer_pointers[i]);   
        message = string_insert(answer[i], message, string_length(message));
    }
    str = "";
    
    //Loop over all message symbol by symbol
    while(count &lt; string_length(message)){
        //Transfer to next line if string is bigger than borders
        if(string_width(str) &gt; width - 2 * padding){
            //Replace space to #
            message = string_delete(message, lastSpace, 1);
            message = string_insert("#", message, lastSpace);
            ds_list_add(start, lastSpace + 1);
        }
        //Check if we reach the end of messgae
        if(string_char_at(message, count) == " "){
            lastSpace = count;
        }else if(string_char_at(message, count) == "#"){
            ds_list_add(start, count);   
        }
        count++;
        
        if(string_height(str) &gt; height - padding){
            line++;
        }
        //Prepare string
        str = string_copy(
            message, 
            ds_list_find_value(start, line), 
            count - ds_list_find_value(start, line)
        );
    }

    //Set line to an end of array - lines displayed
    //line = ds_list_size(start) - 1 - linesDisplayed;
    //show_debug_message(line);
    //And prepare a string to draw on screen
    //str = string_copy(
    //    message, 
    //    ds_list_find_value(start, line), 
    //    count - ds_list_find_value(start, line)
    //);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

draw_set_alpha(0.5);
draw_roundrect_colour(x + 150, y, x + 150 + width, y + height, c_gray, c_gray, false);
draw_set_alpha(1);

draw_set_colour(c_white);

//Displays lines depending of slider value
line = (100 - bar.slider.percentage) / 100 * (ds_list_size(start) - 1 - linesDisplayed);
line = round(line);

topLine = 0;
downLine = 0;
//Lines displayed at screen

if(ds_list_size(start) &gt; linesDisplayed)
{
    if(line &lt; ds_list_size(start) - 1 - linesDisplayed){
        topLine = line;
        downLine = line + linesDisplayed;        
    }
    else if(line == ds_list_size(start) - 1 - linesDisplayed and ds_list_size(start) != 11){
        topLine = line + 1;
        downLine = ds_list_size(start) - 1;
    }
    else if(line == ds_list_size(start) - 1 - linesDisplayed and ds_list_size(start) == 11){
        var l = (100 - bar.slider.percentage) / 100 *
            (ds_list_size(start) - linesDisplayed);
        if(l == 0)
        {
            topLine = 0;
            downLine = ds_list_size(start) - 2;
        }
        else
        {
            topLine = 1;
            downLine = ds_list_size(start) - 1;
        }
        
    }
}else
{
    topLine = 0;
    downLine = ds_list_size(start) - 1;
}

draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_font(Underdog_20);
//draw_text(x + 150 + padding, y + padding, str);

for(var i = 1; i &lt;=iterator; i++)
    answerVisible[i] = false;

for(i = 0; i &lt; linesDisplayed; i++)
    lineColor[i] = "white";
    
visibles = 0;
var j = 0;
for(i = topLine; i &lt;= downLine; i++)
{
    if(i != downLine)
    {   
        str = string_copy(
            message,
            ds_list_find_value(start, i),
            ds_list_find_value(start, i + 1) - ds_list_find_value(start, i)
        );
    }
    else
    {   //Count - how many symbols are in whole message
        str = string_copy(
            message,
            ds_list_find_value(start, i),
            count - ds_list_find_value(start, i)
        );
    }
    //If answers zone is begun, draw text with red
    //And draw line between answers and main text
    var answers = string_pos("1:", str);
    if(answers != 0){
        draw_line(x + 150 + padding, y + j * padding * 1.9,
            x + 700, y + j * padding * 1.9);
        for(var h = j; h &lt; linesDisplayed; h++){
            lineColor[h] = "red";
        }
    }
    for(var a = 1; a &lt;= iterator; a++){
        number = string_pos(string(a) + ":", str);
        if(number != 0){
            ds_grid_set(answersGrid, a - 1, 0, x + 150 + padding);
            ds_grid_set(answersGrid, a - 1, 1, y + j * padding * 1.9);
            answerVisible[a] = true;
            answerLine[visibles] = j;
            visibles++;
        }
    }
    j++;
}


for(i = 1; i &lt;= visibles; i++)
{
    if(answerVisible[i])
    {
        if(i &lt; visibles)
        {
            if(point_in_rectangle(mouse_x, mouse_y,
                ds_grid_get(answersGrid, i - 1, 0),
                ds_grid_get(answersGrid, i - 1, 1),
                ds_grid_get(answersGrid, i, 0) + 550, 
                ds_grid_get(answersGrid, i, 1) ))
            {
                
                for(a = answerLine[i - 1]; a &lt; answerLine[i]; a++)
                    lineColor[a] = "pink";
                    
                if(mouse_check_button_pressed(mb_left))
                {
                    var t = ds_grid_get(answersGrid, i - 1, 2);
                    if(t != 50)
                    {
                        pointer = t - 1;
                        set_data = true;  
                    }
                    else
                    {
                        instance_deactivate_object(obj_slider_vert);
                        instance_deactivate_object(obj_bar_vert);
                        obj_global_control.dialogue_on = true;
                        obj_global_control.back_to_circle = true;
                        instance_deactivate_object(obj_dialogue_new);   
                    }  
                }
            }
        }else if(i == visibles)
        {
            if(point_in_rectangle(mouse_x, mouse_y,
                ds_grid_get(answersGrid, i - 1, 0),
                ds_grid_get(answersGrid, i - 1, 1),
                x + 150 + padding + 550, 
                y + j * padding * 1.9))
            {
                
                for(a = answerLine[i - 1]; a &lt; linesDisplayed; a++)
                    lineColor[a] = "pink";
                    
                if(mouse_check_button_pressed(mb_left))
                {
                    var t = ds_grid_get(answersGrid, i - 1, 2);
                    if(t != 50)
                    {
                        pointer = t - 1;
                        set_data = true;  
                    }
                    else
                    {
                        instance_deactivate_object(obj_slider_vert);
                        instance_deactivate_object(obj_bar_vert);
                        obj_global_control.dialogue_on = true;
                        obj_global_control.back_to_circle = true;
                        instance_deactivate_object(obj_dialogue_new);
                    }  
                }
            }
        }   
    }
}

j = 0;
for(i = topLine; i &lt; downLine; i++)
{   
    str = string_copy(
        message,
        ds_list_find_value(start, i),
        ds_list_find_value(start, i + 1) - ds_list_find_value(start, i) - 1
    );
    var hash = string_pos("#", str);
    if(hash != 0){
        str = string_delete(str, hash, 1);
        str = string_insert(" ", str, hash);
    }
    
    if(lineColor[j] == "white")
        draw_set_colour(c_white);
    else if (lineColor[j] == "red")
        draw_set_colour(c_red);
    else if (lineColor[j] == "pink")
        draw_set_colour(make_color_rgb(255, 182, 193));
    draw_text(x + 150 + padding, y + j * padding * 1.9, str);
    j++;
}

if(downLine == ds_list_size(start) - 1){
    str = string_copy(
        message,
        ds_list_find_value(start, downLine),
        count - ds_list_find_value(start, downLine)
    );  
    hash = string_pos("#", str);
    if(hash != 0){
        str = string_delete(str, hash, 1);
        str = string_insert(" ", str, hash);
    }
    if(lineColor[j] == "white")
        draw_set_colour(c_white);
    else if (lineColor[j] == "red")
        draw_set_colour(c_red);
    else if (lineColor[j] == "pink")
        draw_set_colour(make_color_rgb(255, 182, 193));
    draw_text(x + 150 + padding, y + j * padding * 1.9, str);
    j++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
